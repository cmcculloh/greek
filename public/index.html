<link href="styles.css" rel="stylesheet" type="text/css">
<p style="padding: 15px;">Use W,A,S,D keys to move around the board. Each time you try and move into a new space an alert will appear. Say the letter that you see out loud and then click "ok". A prompt will appear telling you the answer. If you got the answer right, click "ok", otherwise click "cancel".</p>
<p style="padding: 15px;"><input type="checkbox" id="hardmode"/> Check this box to have to type the name of the letter instead.</p>

<div id="page">

</div>

<div id="steve"></div>
<div id="zombie" class="sheep" style="position: absolute;"></div>
<div id="zombie1" class="sheep" style="position: absolute;"></div>
<div id="zombie2" class="sheep" style="position: absolute;"></div>
<div id="zombie3" class="sheep" style="position: absolute;"></div>

<div id="scoreBoard"></div>

<script>

// const additionQuestion = (number) => {
// 	let sub = Math.floor(Math.random() * number);
// 	if (sub === 0) sub = 1;

// 	const theirAnswer = prompt(`${sub} + ${number - sub} =`);

// 	return theirAnswer * 1 === number * 1;
// }

// const BLOCKS = {
// 	D: { block: 'dirt', test: () => additionQuestion(5) },
// 	T: { block: 'tree', test: () => additionQuestion(6) },
// 	W: { block: 'water', test: () => additionQuestion(7) },
// 	S: { block: 'stone', test: () => additionQuestion(8) },
// 	F: { block: 'farm', test: () => additionQuestion(9) },
// 	G: { block: 'grass', test: () => additionQuestion(10) }
// }

// const multiplicationQuestion = (number) => {
// 	let factor = Math.ceil(Math.random() * 12);

// 	const theirAnswer = prompt(`${number} * ${factor} =`);

// 	return theirAnswer * 1 === number * factor;
// }

// const BLOCKS = {
// 	D: { block: 'dirt', test: () => multiplicationQuestion(5) },
// 	T: { block: 'tree', test: () => multiplicationQuestion(6) },
// 	W: { block: 'water', test: () => multiplicationQuestion(7) },
// 	S: { block: 'stone', test: () => multiplicationQuestion(8) },
// 	F: { block: 'farm', test: () => multiplicationQuestion(9) },
// 	G: { block: 'grass', test: () => multiplicationQuestion(10) }
// }


const config = {
	written: false,
	questions: [
		{ question: ['Α', 'α'], answer: ['alpha'], asked: 0, correct: 0 },
		{ question: ['Β', 'β'], answer: ['veeta', 'beeta', 'beta'], asked: 0, correct: 0 },
		{ question: ['Γ', 'γ'], answer: ['gamma', 'ghamma'], asked: 0, correct: 0 },
		{ question: ['Δ', 'δ'], answer: ['delta'], asked: 0, correct: 0 },
		{ question: ['Ε', 'ε'], answer: ['epsilon'], asked: 0, correct: 0 },
		{ question: ['Ζ', 'ζ'], answer: ['dzeeta', 'zeeta', 'zeta', 'dzeta'], asked: 0, correct: 0 },
		{ question: ['Η', 'η'], answer: ['eta', 'eeta'], asked: 0, correct: 0 },
		{ question: ['Θ', 'θ'], answer: ['theeta', 'theta'], asked: 0, correct: 0 },
		{ question: ['Ι', 'ι'], answer: ['iota'], asked: 0, correct: 0 },
		{ question: ['Κ', 'κ'], answer: ['kappa'], asked: 0, correct: 0 },
		{ question: ['Λ', 'λ'], answer: ['lambda', 'lamtha'], asked: 0, correct: 0 },
		{ question: ['Μ', 'μ'], answer: ['mi', 'mu'], asked: 0, correct: 0 },
		{ question: ['Ν', 'ν'], answer: ['ni', 'nu'], asked: 0, correct: 0 },
		{ question: ['Ξ', 'ξ'], answer: ['ksi', 'xi'], asked: 0, correct: 0 },
		{ question: ['Ο', 'ο'], answer: ['omicron'], asked: 0, correct: 0 },
		{ question: ['Π', 'π'], answer: ['pi', 'pee'], asked: 0, correct: 0 },
		{ question: ['Ρ', 'ρ'], answer: ['ro', 'rho'], asked: 0, correct: 0 },
		{ question: ['Σ', 'σ', 'ς'], answer: ['sigma'], asked: 0, correct: 0 },
		{ question: ['Τ', 'τ'], answer: ['taf', 'taff'], asked: 0, correct: 0 },
		{ question: ['Υ', 'υ'], answer: ['ypsilon', 'upsilon'], asked: 0, correct: 0 },
		{ question: ['Φ', 'φ'], answer: ['phi', 'fee', 'fi'], asked: 0, correct: 0 },
		{ question: ['Χ', 'χ'], answer: ['chi'], asked: 0, correct: 0 },
		{ question: ['Ψ', 'ψ'], answer: ['psi'], asked: 0, correct: 0 },
		{ question: ['Ω', 'ω'], answer: ['omega'], asked: 0, correct: 0}
	]
}

const askQuestion = (config, question) => {
	const variation = Math.floor(Math.random() * question.question.length);
	let correct = false;

	if (config.written) {
		const theirAnswer = prompt(`what letter is "${question.question[variation]}"`);

		correct = question.answer.includes(theirAnswer.toLowerCase());

		alert(`${correct ? 'Correct!' : 'Incorrect.'} The letter "${question.question[variation]}" is "${question.answer[0]}".`);
	} else {
		alert(`what letter is "${question.question[variation]}"?`)

		correct = confirm(`The letter "${question.question[variation]}" is "${question.answer[0]}".`);
	}

	question.asked += 1;

	if (correct) { question.correct += 1; }

	return correct;
}


const easyQuestion = (config) => {
	const easyQuestions = config.questions.filter(question => question.asked === question.correct);

	const question = easyQuestions[Math.floor(Math.random() * config.questions.length)];

	return askQuestion(config, question);
}

const hardQuestion = (config) => {
	let question = config.questions[Math.floor(Math.random() * config.questions.length)]

	const hardQuestions = config.questions.filter(question => question.asked !== question.correct);

	if (hardQuestions.length > 0) {
		question = hardQuestions[Math.floor(Math.random() * hardQuestions.length)];

		console.log(hardQuestions.length, hardQuestions.reduce((qs, q) => `${qs}, ${q.question[0]}`, ''), question.question[0])
	}

	return askQuestion(config, question);
}

const anyQuestion = (config) => {
	const question = config.questions[Math.floor(Math.random() * config.questions.length)];

	return askQuestion(config, question);
}

const reward = (who, amount, item) => {
	who.points += amount;
	who.items = who.items || {};
	who.items[item] = who.items[item] || 0;
	who.items[item]++;

	let html = `<ul>
			<li>Points: ${who.points}</li>`;

	for (const item in who.items) { html += `<li>${item}: ${who.items[item]}</li>`; }

	html += `</ul>`;

	document.querySelector('#scoreBoard').innerHTML = html;
}


const BLOCKS = {
	D: { block: 'dirt', test: () => easyQuestion(config), reward: (player) => reward(player, 100, 'dirt') },
	T: { block: 'tree', test: () => hardQuestion(config), reward: (player) => reward(player, 300, 'wood') },
	S: { block: 'stone', test: () => hardQuestion(config), reward: (player) => reward(player, 300, 'stone') },
	W: { block: 'water', test: () => hardQuestion(config), reward: (player) => reward(player, 300, 'water') },
	F: { block: 'farm', test: () => hardQuestion(config), reward: (player) => reward(player, 300, 'carrots') },
	G: { block: 'grass', test: () => anyQuestion(config), reward: (player) => reward(player, 200,'grass seed' ) }
}



DEFAULT = BLOCKS.G;

const POSSIBILITIES = Object.values(BLOCKS);


const generateBoard = (BOARD, width, height) => {
	for (let ri = 0; ri < height; ri++) {
		BOARD[ri] = BOARD[ri] || [];

		for (let ci = 0; ci < width; ci++) {
			let possibleBlocks = [
				{
					chance: Math.random() * 10,
					type: DEFAULT
				},
				{
					chance: Math.random() * 11,
					type: BOARD[ri][ci - 1] || DEFAULT
				},
				{
					chance: Math.random() * 11,
					type: BOARD[ri-1] && BOARD[ri-1][ci] || DEFAULT
				},
				{
					chance: Math.random() * 9,
					type: POSSIBILITIES[Math.floor(Math.random() * POSSIBILITIES.length)] || DEFAULT
				}
			]

			let sorted = possibleBlocks.sort((a, b) => {
				if (a.chance < b.chance) { return 1 }
				else if (a.chance > b.chance) { return -1 }
				else { return 0 }
			});

			BOARD[ri][ci] = sorted[0].type;
		}
	}

	console.log(BOARD);

	return BOARD;
}


let BOARD = []
const BOARD_WIDTH = 30;
const BOARD_HEIGHT = 200;

BOARD = generateBoard(BOARD, BOARD_WIDTH, BOARD_HEIGHT);

const blockTry = (blockTarget, entity, BLOCKS) => {
	const targetType = blockTarget.getAttribute('data-type');
	const block = BLOCKS[Object.keys(BLOCKS).find((candidate) => BLOCKS[candidate].block === targetType)]

	const success = block.test();

	if (success) block.reward(entity);

	return success;
}

const blockReveal = (target) => {
	target.classList.remove('unsolved');
}

const placeEntity = (entity, movePositionBy) => {
	entity.position[1] = entity.position[1] + movePositionBy[1];
	entity.position[0] = entity.position[0] + movePositionBy[0];

	entity.DOM.style.top = `${(entity.position[1] * 30) + 146}px`;
	entity.DOM.style.left = `${entity.position[0] * 30}px`;

	if (entity.revealsBlocks) {
		blockReveal(document.querySelector(`#row${entity.position[1]}cell${entity.position[0]}`))
	}

	return entity;
}

const board = document.createElement('div');
BOARD.forEach((row, ri) => {
	const rowDOM = document.createElement('div');
	rowDOM.classList.add('row');

	row.forEach((cell, ci) => {
		const cellDOM = document.createElement('div');

		cellDOM.id = `row${ri}cell${ci}`;
		cellDOM.setAttribute('data-answer', cell.answer);
		cellDOM.setAttribute('data-type', cell.block);
		cellDOM.classList.add('block', 'unsolved', cell.block);

		rowDOM.appendChild(cellDOM);
	});

	board.appendChild(rowDOM);
});

const page = document.querySelector('#page');
page.appendChild(board);

let player = {
	DOM: document.querySelector('#steve'),
	revealsBlocks: true,
	points: 0,
	items: {},
	position: [1, 1]
}

let mobs = [
	{
		DOM: document.querySelector('#zombie'),
		revealsBlocks: false,
		points: 0,
		items: {
			"sword": 1
		}
	},
	{
		DOM: document.querySelector('#zombie1'),
		revealsBlocks: false,
		points: 0,
		items: {
			"sword": 1
		}
	},
	{
		DOM: document.querySelector('#zombie2'),
		revealsBlocks: false,
		points: 0,
		items: {
			"sword": 1
		}
	},
	{
		DOM: document.querySelector('#zombie3'),
		revealsBlocks: false,
		points: 0,
		items: {
			"sword": 1
		}
	}
]

const initMobs = (mobs) => {
	mobs.forEach(mob => {
		const randX = Math.floor(Math.random() * BOARD_WIDTH);
		const randY = Math.floor(Math.random() * BOARD_HEIGHT);

		mob.position = [ randX, randY ];

		placeEntity(mob, [0,0]);
	});

	return mobs;
}

const moveMobs = (mobs, player) => {
	mobs.forEach(mob => {
		let newPosition = [ 0, 0 ]
		mob.position[0] !== player.position[0] ? mob.position[0] > player.position[0] ? newPosition[0]-- : newPosition[0]++ : mob.position[0];

		mob.position[1] !== player.position[1] ? mob.position[1] > player.position[1] ? newPosition[1]-- : newPosition[1]++ : mob.position[1];

		placeEntity(mob, newPosition)

		console.log('new mob position', mob.position)
	});

	return mobs;
}

placeEntity(player, [0,0]);
mobs = initMobs(mobs);

document.addEventListener('keypress', (e) => {
	let movePositionBy = [ 0, 0 ]
	switch(e.charCode) {
		case 97:
			// console.log('left')
			movePositionBy[0]--;
			break;
		case 119:
			// console.log('up')
			movePositionBy[1]--;
			break;
		case 100:
			movePositionBy[0]++;
			// console.log('right')
			break;
		case 115:
			movePositionBy[1]++;
			// console.log('down')
			break;
		default:
			console.log(e.charCode)
	}

	const attemptBlock = document.querySelector(`#row${player.position[1] + movePositionBy[1]}cell${player.position[0] + movePositionBy[0]}`);

	mobs = moveMobs(mobs, player);

	if (attemptBlock.classList.contains('unsolved')){
		const success = blockTry(attemptBlock, player, BLOCKS);
		if(success){
			player = placeEntity(player, movePositionBy);
		}
	} else {
		player = placeEntity(player, movePositionBy);
	}
});

document.querySelector('#hardmode').addEventListener('change', (e) => {
	config.written = e.target.checked;
})

document.querySelector('#hardmode').checked ? config.written = true : config.written = false;




</script>